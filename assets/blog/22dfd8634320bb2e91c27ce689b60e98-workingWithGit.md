
这个指南是用来协助开发人员来约定如何使用Git的。
里面提到的一些内容是我们觉得会有助于开发人员更好地协作的。
但是这些约定并不是强制的，你应该使用最适合你的方式。

### Git远程
我们推荐这样的约定：将你要贡献代码的远程仓库称为`origin`，
而用你的用户名来命名你从这个仓库fork出来的远程仓库。
这个约定在你从多个fork之间共享代码的时候会非常管用。而我们会在整个指南里面贯彻这个约定。这也是
[GitHub命令行工具](https://github.com/github/hub)开箱即有的运行最好的约定。

### 分支

正常来说，所有工作都应该在分支上面完成。
如果你直接在master上面工作的话，那么在同一时间里，你就只能提一个pull request(Gitlab中称为merge request),
因为如果你试图从master上面提交第二个的时候，
第二个就会包含你的第一个和第二个commit。
在分支上工作允许你将pull request从彼此之间分离开来。
至于如何称呼你自己的分支那就取决于你自己了。
一些人喜欢在分支名里面包含issue号，也有些人喜欢使用等级结构来进行命名。

### Squash（压缩）提交

我们倾向于每一个pull request都是一个单独的提交。理由如下：

* 回滚单个提交到稳定分支比回滚一组提交更加简单，并且出错的概率更小。
如果变更只在一个提交里面 ，回滚就根本没有机会污染分支，不管整个变更是不是cherry pick过来的。

* 我们的目标在于master分支永远都是可以发布的状态，
而这包括历史上的每个点都是可发布，而不仅仅是现在而已。
如果我们需要回滚某个提交的话，我们必须确信在这个提交之前的分支状态是稳定并且可发布的。

* 如果变更都是在一个提交里面的话，这有助于我们在历史纪录里面回溯变更的内容。

当然，也存在着不适合使用squash的场景，但是这些都应该根据场景进行逐个分析。
下面列举了一些我们并不要求压缩提交的例子：

* 当pull request里面包含着多于一个人的提交的时候。在这个场景里面，我们倾向于同一个人的所有提交都是squash的。
* 当pull request来自于被社区内部共享的fork或者分支的时候。这时候如果重写变更记录会导致从这个fork或者分支拉取变更的人遇到问题。
* 当pull request包含非常大的工作量的时候，提交记录会有助于理解工作的演化。

但是，在大多数情况下，如果你的pull request包含多个提交的话，那么你需要按照如下步骤进行操作：

1. 确保你的repo包含核心master分支的所有变更：

        git fetch origin

2. 开始进行一个交互式的rebase:

        git rebase -i origin/master

3. 这个命令会在你的编辑器里面打开一个屏幕，允许你讲述你在每个提交里面做了什么。如果第一个提交的提交信息适用于描述所有提交，那么就可以保留它，否则就将它之前的命令从`pick`改成`reword`.
4. 对于剩下的每个提交，将命令从`pick`改成`fixup`。这会告诉git将每一个提交合并到之前的提交里面去，并使用之前提交的commit message.
5. 保存文件之后退出编辑器。Git会开始rebase的操作。如果你`reword`了第一个提交，那么git会给你打开一个编辑器来让你填入新的提交信息。如果填完了以后一切正常，那么工作就完成了。但是在将你的变更应用到最新的master分支的时候，可能会发生冲突，那么这个时候你就需要解决冲突，然后运行命令：`git rebase --continue`。如果含有冲突的变更很多，那么也许这个步骤需要被重复很多次。
6. 好了，现在你应该已经rebase好了，这个时候就要推送你的所有变更了。如果你在squash之前已经提交过了分支（包含你已经创建了pull request的场景），那么你就需要做一个强制推送。可以通过如下命令来完成：

        git push yourremote yourbranch --force

### 响应评审意见或者构建失败

如果你的pull request没有通过CI构建，或者如果我们在代码评审之后告知你需要更新你的pull request，或者如果有任何其他你需要更新你的pull request的理由，那么与其创建一个新的提交，不如改进已有的。这个操作可以通过提交的时候使用`--amend`标志来完成：

    git commit --amend

amend完成之后，我们又一次需要通过强制提交标志`--force`来进行提交：

    git push yourremote yourbranch --force

### 重新开始

有时有人发现他们的pull request完全错了，然后想重新开始。这样也可以，但是没有必要关闭原来的pull request然后起一个新的。你可以使用强制推送来将一个全新的分支推送到这个pull request里面。

重新开始之前，确保你已经获取核心仓库的最新变更，然后从那一个点创建一个新的分支：

    git fetch origin
    git checkout -b mynewbranch origin/master

然后在这个分支上进行你的工作。当你准备好了要提交pull request的时候，假设你的老的分支名是`myoldbranch`，将你的新的分支强制推送到你的仓库里面的老的分支里面去：

    git push yourremote mynewbranch:myoldbranch --force

这之后，pull request会更新成你的新的分支。

### 关于变更记录

也许你听说过这么一个说法，就是你不应该在发布之后修改git的历史纪录。但是使用`rebase`和`commit --amend`都会修改变更记录，而使用`push --force`会发布你的整个变更记录。

当然存在着发布之后不应该修改git历史纪录的情况，尤其是在其他人fork了你的仓库，或者从你的仓库拉取了更新的时候。
这个时候修改变更记录的话会使得其他人没有办法安全地将你在仓库里面的变更合并到他们自己的仓库里面去。基于这个理由，需要被贡献代码的核心仓库永远不应该修改自己的历史纪录。

然而，当你在自己的私人fork里面的时候，或者在只是为了pull request而创建的分支上时，情况就完成不一样了。
这个工作流程的本质是你的变更在合并到master分支的时候才是真正地“被发布”。在此之前，你想怎样折腾你的分支都是可以的。

当然，如果你的分支是很多人协作的，并且你相信其他人有很好的理由从你的分支进行拉取。那么这个时候请让管理核心开发库的人员悉知。这个时候，就不应该强制要求你的pull request是压缩了的提交，因为这样做并不合理。

