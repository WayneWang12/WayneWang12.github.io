---
withComments: true
pageId: principle of reactive stream
withAds: true
---

反应式流回压的原理
------------
反应式编程模型是目前编程世界的大势所趋。Java服务框架中的扛把子Spring会在5.0中全面拥抱反应式编程模型，这意味着广大的Java程序员都开始有可能接触反应式编程的思想，除非他们的项目永远被三体人锁死在了Spring 4。新版本的Spring全面拥抱了[反应式宣言](https://www.reactivemanifesto.org/zh-CN)(该宣言中文版由何品主要翻译，我和Hawstein、CTAO、Neo一起校审，并作为附录存于《反应式设计模式》一书中。书作者Roland Kuhn是最早的起草人之一)中的思想，并且提供从Threaded Server转向Event-based Server的途径，并且反应式流会在框架中大量应用。很多人也许很早就听说过[Rx Extensions](http://reactivex.io/)，知道Rx .Net, RxJs, RxJava，RxScala，但是大部分也许对其中的模式和原理不太了然。为什么加个Rx就比我们平时用的集合框架高级了呢？反应式流的什么特性令其独树一帜了？这一篇里面，我们来揭示一下反应式流的原理。至于反应式编程及其设计模式，等我们翻译的《反应式设计模式》出版之后，我会第一时间给大家推送相关信息，敬请期待。

### 什么是反应式流

首先要明确一点，反应式流只是进行流处理的一种方式而已。它并不局限于是否使用了一种反应式相关的框架，而是你处理反应式流的方式。如果你用一种带回压的非阻塞模式进行流式处理，那么你就应用了反应式流。如下是来自[反应式流官网](http://www.reactive-streams.org/)的定义：

>Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure.

你可以看到，反应式流只是一个倡议。它提议，要提供一种标准的、应用了非阻塞的回压机制的异步流式处理方法。并且，经过社区的持续努力，在JDK 9中，实现了和反应式流等价的接口[java.util.concurrent.Flow](https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html)

### 什么是回压

回压的英文是 _back pressure_。传统行业以及早期的翻译都是"背压"。但是这个翻译由于无法体现其具体的意思，所以我们在翻译《反应式宣言》和《反应式设计模式》的时候将其定为"回压"。记忆以及理解它相比"背压"就简单多了，就是当下游处理单元无法及时处理上游发出来的数据时，就对上游发回一个压力信息，这就是"回压"。当回压产生的时候，上游就应该放慢其发送数据的速度，以保证系统在一个合理的、可以承受的速度下运转，避免因为数据速率产生过快而导致系统崩溃。而由于处理的过程是异步的，如果瓶颈是在下游的处理单元，那么上游空出的资源就可以用来执行其他任务，从而保障了系统资源利用率的提升。传说淘宝在上一年度进行反应式架构升级之后，其内部应用服务器的资源使用率降低非常明显。

### 流式处理面临的问题

一般来说，我们在处理流式数据的时候，面临的问题可能有如下几个：

1. 无法确定大小和速度的活跃数据流；
2. 数据跨越异步边界（独立的生产者到独立的消费者）；
3. 生产者和消费者的速率不一致；

由之而衍生的问题可以罗列如下：

1. 难以预知数据流对处理资源的需求程度；
2. 异步编程问题；
3. 分为两种情形；
   1. 如果生产者的速率快于消费者，消费者最终可能被生产者压垮；
   2. 如果消费者的速率快于生产者，消费者需要不时耗费资源来轮询生产者。
   
那么，回压如何解决这些问题呢？我们来分情况罗列。

### 速率可控的生产者

速率可控的生产者的特性在于，它可以按照消费者的要求给它们发送任务。在这个场景里面我们设定如下任务：

1. 利用Akka的Actor来计算调和级数:
> 1 - 1/2 + 1/3 - 1/4 ... (其值向2的自然对数收敛，近似值为0.693147180559945...)
2. 设置一个管理者Actor负责分发计算任务和符号；
3. 由工作者Actor来执行相对耗时的浮点数计算。

这里，我们会引入一种模式，称为 _拉取模式_ :

> 让消费者向生产者对数据的批量大小提出要求。

意思就是说，由消费者来决定生产者应该给与其多少数据，而不是由生产者来决定。那么，在Akka的Actor模型下如何实现这个模式呢？我们先来看下具体的逻辑流程：

1. 工作者Actor启动之后，向管理者发起工作请求。每个工作请求请求10条数据；
2. 管理者Actor根据请求的数据多少，将工作发回给工作者；
3. 当工作者已经请求但是未接收的工作数据少于5个的时候，就再次发送10个请求
4. 如此往复，直到达到指定精度，或者完成所有工作请求。

首先，我们先定义相关的样例类：

@@snip [ReactiveStreamDemo.scala]($reactive-stream-demo$/ReactiveStreamDemo.scala) {  #pull-pattern-classes }

Job是由管理者下发给工作者的内容，JobResult是计算出来的结果，WorkRequest是工作者发回给管理者的工作请求。其中包含着工作者自己的`ActorRef`，和请求的项目数量。

于是，工作者逻辑可以如下实现：

@@snip [ReactiveStreamDemo.scala]($reactive-stream-demo$/ReactiveStreamDemo.scala) {  #pull-pattern-worker }


在启动的时候，就调用`request()`函数请求任务，之后，每当已经请求但是未处理的任务少于5个时，就会又一次发送工作请求给管理者，要求发送更多的任务过来。

而管理者的代码则是如下：

@@snip [ReactiveStreamDemo.scala]($reactive-stream-demo$/ReactiveStreamDemo.scala) {  #pull-pattern-manager }

如此，只需要生成管理者Actor，我们的计算任务就可以开始了。

@@snip [ReactiveStreamDemo.scala]($reactive-stream-demo$/ReactiveStreamDemo.scala) {  #start-manager }

最终我们会得到结果：

> final result: 0.693147680560195309417231996458176568325500134359192754120687759493393535594694716971113326967369656239812, time spent is 1471ms

读者如果有兴趣的话，可以思考下如果直接将任务分布给8个消费者的代码应该如何写。在这种情况下，也许会产生两种问题：

1. 消费者的缓冲队列是无界的话，在数据量大的情况下可能会导致内存耗尽；
2. 消费者的队列如果是有界的阻塞队列，那么在消费者速率较慢的时候，可能会导致生产者的阻塞。

另外，还需要思考的是，应该按照怎样的数量分布任务给消费者。因为预先决定的平均分布很有可能得不到平均的执行情况，有的消费者可能会快一点，有的消费者可能会慢一点。平均分布的话，最终的执行时间可能取决于最慢的消费者的消费速率。

而且这种分布，假设其中一个工作者失败了，那么所有分配给它的任务都会丢失。此时的恢复过程就比上述的模式更加复杂。读者可以思考一下，如何分别给上述的拉取模式和这种模式执行故障恢复。

### 拉取模式的优点

使用拉取模式，我们可以实现如下好处：

1. 当生产者快于消费者的时候，生产者最终会缺少工作请求，此时只要消费者发出工作请求，其需求就能立即得到满足，整个系统运行得就好像在拉取状态；
2. 当生产者慢于消费者的时候，消费者最终会有违背满足的需求，此时只要生产者产生了任务，就能立即发送给消费者，整个系统运行得就好像在推送状态；
3. 在负载一直变化的情况下，这个机制将会自动地在前述两种模式下切换，而不需要任何额外的协调工作。整个系统运行的就好像在一种动态推拉的状态下；
4. 只要能确定消费者的数量，这个过程即使是异步的，它也不会需要任何的加锁机制。

在这个过程中，回压体现在哪里呢？我们可以看到，当消费者无法处理任务的时候，生产者也不会向其发送多余的任务，因为消费者无力向生产者发送更多的工作请求。所以这里的回压是通过工作请求的缺失来体现的。

进一步，我们假设生产者只是一个中间节点，其任务是由上游的生产者传递给它的，并且它也按照上述方法实现了回压机制，则由上游至中间节点至消费者的过程中，这一整个链条都能实现回压。消费者回压中间节点，中间节点回压上游生产者。所以，由实现了回压机制的处理单元组合成的流程，回压机制可以在整个流程上传递。所以，整个系统都能实现动态推拉的特性，使得系统健壮而高效。

### Akka Stream实现一版上述逻辑

Akka Stream是反应式流的一种实现。其内部的处理单元都良好地实现了回压机制。我用Akka Stream实现了一版本的上述功能，代码如下：

@@snip [ReactiveStreamDemo.scala]($reactive-stream-demo$/ReactiveStreamDemo.scala) {  #pull-pattern-stream }

最终打印结果为：

> final result: 0.693147680560195309417231996458176568325500134359192754120687759493393535594694716971113326967369656239812, time spent is 551ms

可以看到，由akka stream实现起来，逻辑清晰又简单，并且效率得到了很高的提升，由1471ms提升到了551ms。

至于如何实战Akka Stream，10月20日在上海会有一个Scala Meetup，我会在上面做一个Akka Stream In Action的分享，希望到时候关注。后续宣传图片和地点，会在本公众号上发布。

### 更多关于流量控制的内容

反应式流的回压机制在《反应式设计模式》中被称为流量控制的一种。实际上，为了处理流量，还有更多内容要讲。但是一篇则会显得篇幅太长。有兴趣的同学可以等待《反应式设计模式》出版之后自行阅读，或者等我这个不知道什么时候心血来潮才会写一篇公众号的懒人更新后续内容。欢迎大家持续关注我的公众号，或者博客。我尽量不太懒。
