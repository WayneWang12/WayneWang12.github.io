
上期我们讲了CQRS，其中提到了Event Sourcing，并且顺便也和大家提了一下这个模式也被Raft所采用。只不过为了方便查询和统计，CQRS加入了Query方面的支持，于是系统便由Event Sourcing转变成了CQRS。上次我们讲CAP的时候就提到了Raft，而趁着五一有时间，我们来好好捋一捋Raft相关的知识点。

其实说起来，Raft并没有什么特别的地方。它不过是《反应式设计模式》里面所讲的主动-被动模式的一种实现，因而也有着模式本身所带来的限制。因为其对强一致性的要求，所以在可用性上会有所牺牲，当可用节点少于多数的时候，系统会变得不可用；因为其只有主动节点处理请求的特性，所以在性能要求高的情况下会有所不足；因为其要互相帮助从失败中进行恢复，所以在失败恢复的过程中会产生激增流量。所以我们需要在使用它的时候审慎一些。现在市面上对Raft算法特别推崇，甚至有一种以为掌握了Raft就掌握了分布式系统的趋势。而这种观点并不可取。这一篇我们深入解析一下Raft算法，并希望借助此篇，能使大家拥有自行判断应该在何种情形下采用Raft算法的能力。

### 主动-被动模式回顾

> 在不同的位置持有副本，但是只允许对于其中一个位置的状态做修改。

为了实现这种模式，集群需要具有以下能力：

1. 集群成员服务，允许发现和枚举所有副本位置;
2. 集群单例机制，保证始终只有一个主动副本在运行；
3. 主动副本，接收来自客户端的更新请求，然后将其广播到所有的被动副本，并在复制成功之后，应答客户端；
4. 数个被动副本，负责持久化状态的更新，并帮助彼此从消息丢失中恢复。

而Raft算法则完成了上述内容。它具有如下特性：

1. 强Leader机制：日志条目只会从Leader流向Follower，若Follower收到了日志写入请求，则其会将请求转发给Leader。这一条对应模式的第三、四条
2. Leader选举机制：集群必须有且只有一个Leader。若Leader所在节点发生失败，则由剩余成员进行选举，选出新任Leader。这一条对应模式的第二条。
3. 成员变更机制：集群可以发现和处理成员变更的信息，并且在此期间，可以保证集群的正常运行。这一条对应模式的第一条。

之后，借助以上机制，我们就可以基于共识算法，来获得一个具有强一致性的分布式系统了。

### 可复制状态机中的共识和一致性

Consistency和Consensus是国内技术翻译中一直会发生混乱的两个词。这个词的混乱使得我们经常弄混一致性和共识之间的区别。两者当然有一定程度上的相关性，不然也不会那么容易混淆。共识算法的采用，一般都是为了达到一致性的结果。但是在分布式系统中，共识和一致性的定义完全不一样。我们可以给出共识和一致性的粗略定义：

1. 共识：一个或者多个进程提议了一个值应当是什么的提议后，最终所有进程对这个值是什么达成了一致的意见；
2. 一致性：数据保持一致，在分布式系统中，可以理解为多个节点中同一数据的值是一致的。

上述的共识问题其实还可以分为拜占庭将军问题和其他共识问题。一致性则可以区分为强一致性和弱一致性，而弱一致性的一种特例就是我们在BASE中会时常采用的E，也就是最终一致性。

Raft算法则是在可复制状态机的基础上提出来的一种算法。其要解决的共识问题则是状态机的变更日志中的第几条日志应当是什么的问题。要注意它可以保证所有**非拜占庭条件**下的数据安全性。也就是说，如果你的系统可能会有拜占庭将军问题的话，那么你就要谨慎考虑对Raft的采用。譬如去中心化的区块链系统，由于节点可能出于经济利益伪造数据，其提议可能会是错误的，此时就需要考虑如何处理节点提出错误提议的情形。

而Raft（包括传统的Paxos算法）没有对**拜占庭将军问题**进行考虑。也就是我们假定系统中没有会给出虚假信息、“叛变革命”的节点(一般情况下也确实不会有)。所有要处理的问题就是Leader会提议将某一条日志作为第N条日志记录下来，Follower负责响应。只要集群中多数节点确认采用之后，则该提议。这之后，每个节点上依据状态机的设定来消费日志，由于变更日志中的每一条日志在不同的节点上都是一样的，所以每个节点都能达到一致的状态。而Raft由于施加了强Leader的设定，Follower只会应答Leader和Candidate的请求，所以所有的读取请求也都会被转发到主动节点上。也就是说，只要系统中多数节点对日志达成了共识，则Leader就可以回复客户端。后续应答客户端的读取状态也是由Leader来负责，所以不会出现我们上一节说的打到不同节点上，读取到不一致状态的问题。因而其保障的是强一致性。

而万一Leader所在的节点发生了失败

