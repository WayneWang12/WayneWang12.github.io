{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Wayne的博客"},{"location":"/index.html#wayne的博客","text":"","title":"Wayne的博客"},{"location":"/index.html#简介","text":"欢迎来到我的博客。本网站使用Lightbend Paradox构建，主要内容会与Scala技术栈相关。偶尔也会穿插一些琐话。欢迎关注我的公众号以及时获得更新信息。","title":"简介"},{"location":"/index.html#目录","text":"2018年8月 使用Paradox构建文档网站 使用Git的一些原则","title":"目录"},{"location":"/2018/index.html","text":"","title":"2018年8月"},{"location":"/2018/index.html#2018年8月","text":"使用Paradox构建文档网站 使用Git的一些原则","title":"2018年8月"},{"location":"/2018/paradox_site_setup.html","text":"","title":"使用Paradox构建文档网站"},{"location":"/2018/paradox_site_setup.html#使用paradox构建文档网站","text":"","title":"使用Paradox构建文档网站"},{"location":"/2018/paradox_site_setup.html#lightbend-paradox简介","text":"Lightbend Paradox是为了软件项目文档而开发的Markdown文档工具。它提供了开箱即用的基本样式、完善的Github Flavor Markdown语法支持，并且可以通过指定的方法进行代码片段引入。结合sbt-site插件，可以非常轻松地做到在本地一键发布博客的过程，或者是通过Github的Travis CI在commit之后进行自动构建发布。对于Scala程序员来说，Paradox最大的好处在于可以使得代码和文档不被割裂。你的文档可以直接放在项目里面，然后通过特定语法将代码引入到文档中，从而使得文档内容可以在IDE里面随着代码变更直接变动，而不需要上下文切换到浏览器这个新环境中进行编写。\n上周我将Paradox引入了自己正在开发的项目里，并且第一次感受到了写文档的乐趣。之后便萌生想法，想要使用Paradox来构建自己的博客。当然，对于博客来说，这个组件并非最好的。但是用来做一些基本的思考记录还是足够的。Paradox最好的归宿是用来做文档网站，结合Github pages，可以轻松地做到版本相关的文档发布。目前基本上Lightbend除了基于Playframework构建的项目是使用早就存在的PlayDocPlugin之外，其他相关的项目都是使用的Paradox来做文档管理，如Akka，Alpakka等，尤其是一些小项目，结合Github pages，相当方便。本篇将介绍如何使用Paradox快速构建文档项目。","title":"Lightbend Paradox简介"},{"location":"/2018/paradox_site_setup.html#sbt配置paradox","text":"在project/plugins.sbt中添加插件：\naddSbtPlugin(\"com.lightbend.paradox\" % \"sbt-paradox\" % \"0.4.0\")\nFull source at GitHub\n在build.sbt中定义项目：\nlazy val docDemo = (project in file(\"docs\")).\n  enablePlugins(ParadoxPlugin).\n  settings(\n    name := \"Demo Project\",\n    paradoxTheme := Some(builtinParadoxTheme(\"generic\"))\n  )\nFull source at GitHub\n之后，你只需要在docs/src/main/paradox中创建index.md文档即可：\n# 示例文档\n\n本文档由Paradox生成。\n\n## 这是会出现在右侧的二级标题\nFull source at GitHub\n然后执行sbt命令paradox，就能在docs/target/paradox/site/main中找到index.html文件，以及其他css和js文件。之后直接浏览器打开index.html即可:\n如果你拿这个页面对比一下Alphakka的文档样式，你会发现两者几乎完全一样，只是Alphakka多了一个Akka的标志而已。\nParadox的所有源文件都是使用的Markdown语法来书写。并且因为与Github结合紧密，所以其采用了Github-flavored风格。它背后的Markdown解析器是由Mathias开发的Pegdown(这哥们儿最有名的库是后来发展成为Akka-http的Spray)。当然，虽然这个库已经不再维护了，但是用来做这里的语法解析也是绰绰有余的。\n到现在我们的文档网站已经做好了。之后便需要按照需求来组织一下页面即可。","title":"Sbt配置Paradox"},{"location":"/2018/paradox_site_setup.html#页面组织","text":"所有页面的第一个标题会成为该页面的标题，不管该标题的级别是什么。页面树是通过在Markdown文档中嵌入用@@@ index容器包裹的内容来解析的。格式如下：\n@@@ index\n\n* [设置](setup/index.md)\n* [用途](usage/index.md)\n\n@@@\nFull source at GitHub\n这里的页面是一个树状的结构。你可以在后面的setup/index.md中继续使用相同的语法进行页面扩展。但是左侧的页面树默认最多只有两级。而且，如果不做特别处理的话，在当前页面是看不到页面树的。不过你可以通过在页面中添加指令\n@@toc { depth=1 }\nFull source at GitHub\n如此之后，在当前页面就也能看到页面层次了。其中depth的设置可以改变页面树的级数。\n以此类推，我们就能构建组织出一个文档项目的完整、清晰的结构。","title":"页面组织"},{"location":"/2018/paradox_site_setup.html#片段引入","text":"Github的Markup有个著名的issue#346，其中维护者明确地拒绝了在Github Markdown中添加嵌入文件片段的请求，而不顾几百个+1的请求。这个需求说实话，确实是个刚需，所以Paradox为我们贴心地做了一下实现。通过以下语法，可以将位于src/main/scala/HelloApp.scala里面的包含在// #hello-example中间的代码片段引入本文件：\n@@snip [HelloApp.scala](../../scala/HelloApp.scala) { #hello-example }\n代码源文件为：\n// #hello-example\nobject HelloApp extends App {\n  println(\"Hello, world!\")\n}\n// #hello-example\n页面中则是如下格式：\nobject HelloApp extends App {\n  println(\"Hello, world!\")\n}\nFull source at GitHub\n注意，不管是什么样的文件，只要文件名、路径对上，Paradox都能帮我们做引入，例如我上面的markdown文档片段就是直接从本docDemo项目的文档中引入进行来的。\n至此，我基本把Paradox里面的主要会用到的内容讲完了。后续如果需要做更多定制化的内容，大家可以直接去看官网文档，包括如何使用本博客采用的主题方式\n接下来我们讲如何使用sbt-site插件","title":"片段引入"},{"location":"/2018/paradox_site_setup.html#sbt-site插件的使用","text":"这些程序员一般都很懒，能代码做掉的事情绝对不手动去做。如果我们只使用paradox的话，我们需要执行sbt命令paradox之后，将生成在target/paradox/site/main里面的文件手动git add和commit到Github上面去，才能发布网站。而为了解决这个多好多步的问题，我们使用sbt-site插件，来让我们只需要执行ghpagesPushSite命令，即可一键发布。\n首先还是添加插件。在project/plugins.sbt中添加：\naddSbtPlugin(\"com.typesafe.sbt\" % \"sbt-site\" % \"1.3.2\")\n\naddSbtPlugin(\"com.typesafe.sbt\" % \"sbt-ghpages\" % \"0.6.2\")\nFull source at GitHub\n其中sbt-site是帮助我们打包网站，sbt-ghpages则帮助我们发布到Github的gh-pages分支。\nNote 注意，加入sbt-site插件之后，之前Paradox指引的类似在build.sbt文件中添加到Compile的属性现在要添加到Paradox才能生效，如： paradoxProperties in Paradox ++= Map(\n  \"github.base_url\" -> s\"https://github.com/WayneWang12/Waynewang12.github.io/tree/blog\",\n  \"snip.project.base_dir\" -> (baseDirectory in ThisBuild).value.getAbsolutePath\n),Full source at GitHub 另外，为了使我们的源文件还是在src/main/paradox里面，你需要在项目中进行如下设定： sourceDirectory in Paradox := sourceDirectory.value / \"main\" / \"paradox\",\n\nsourceDirectory in Paradox in paradoxTheme := sourceDirectory.value / \"main\" / \"paradox\" / \"_template\",\nFull source at GitHub 否则，默认的源文件夹是src/paradox。\n之后，我们需要在build.sbt文件中设置发布文档项目到的目的仓库。例如，本博客的设置为：\nscmInfo := Some(ScmInfo(url(\"https://github.com/WayneWang12/WayneWang12.github.io.git\"), \"git@github.com:WayneWang12/WayneWang12.github.io.git\")),\ngit.remoteRepo := scmInfo.value.get.connection,\nname := \"Wayne's Blog\",\nghpagesBranch := \"master\",\nFull source at GitHub\n注意最后一行的ghpagesBranch := \"master\"。在Github上形如username.github.io的仓库默认是个人主页的主项目，所以这个项目中无法设置gh-pages这个分支，而必须是master。所以这里我做了改变。但是如果是其他项目的话，则可以不加这一行。例如，假如我有一个sbt-site的项目，在gh-pages分支设置好了以后，我就可以通过http://waynewang12.github.io/sbt-site来访问它了。\n上述设置完成以后，我们接下来需要做一次初始化设置：\nsbt clean make-site                             # <1> Build the site\norigin=$(git remote get-url origin)             # <2> Save the current remote for later\ncd target/site\ngit init                                        # <3> Create site repo and add initial content\ngit add .\ngit commit -m \"Initial import of GitHub Pages\"\ngit push --force \"$origin\" master:gh-pages      # <4> Publish the repo's master branch as gh-pages\n注意，如上所说，最后一行的gh-pages你需要根据你的项目性质做改变。例如，本博客的源代码就在blog分支，而Github pages内容则在master分支。所以第四步我执行的是：\ngit push --force \"$origin\" blog:master      # <4> Publish the repo's master branch as gh-pages\n这一次完成了之后，每次我需要发布新内容，就只需要执行sbt命令\nghpagesPushSite\n就可以发布新内容了。","title":"sbt-site插件的使用"},{"location":"/2018/paradox_site_setup.html#总结","text":"怎么样，对于基于sbt构建项目的Scala程序员来说，是不是很简单，很方便？最棒的一点是你可以将编译通过的代码直接引入到文档里面去，之后就算代码做了变更，文档内容也会随之变更，而不会出现代码改了文档没改的尴尬情形。并且因为所有的一切都在IDE里面完成，程序员完全不需要进行场景切换，所以效率会更高，也更有动力去编写文档。\n所以，十分推荐有文档需求的Scala程序员来尝试一下本插件。并且自行琢磨出一套文档和代码一起持续演进的流程，来与大家分享。","title":"总结"},{"location":"/2018/workingWithGit.html","text":"","title":"使用Git的一些原则"},{"location":"/2018/workingWithGit.html#使用git的一些原则","text":"这个指南是用来协助开发人员来约定如何使用Git的。 里面提到的一些内容是我们觉得会有助于开发人员更好地协作的。 但是这些约定并不是强制的，你应该使用最适合你的方式。","title":"使用Git的一些原则"},{"location":"/2018/workingWithGit.html#git远程","text":"我们推荐这样的约定：将你要贡献代码的远程仓库称为origin， 而用你的用户名来命名你从这个仓库fork出来的远程仓库。 这个约定在你从多个fork之间共享代码的时候会非常管用。而我们会在整个指南里面贯彻这个约定。这也是 GitHub命令行工具开箱即有的运行最好的约定。","title":"Git远程"},{"location":"/2018/workingWithGit.html#分支","text":"正常来说，所有工作都应该在分支上面完成。 如果你直接在master上面工作的话，那么在同一时间里，你就只能提一个pull request(Gitlab中称为merge request), 因为如果你试图从master上面提交第二个的时候， 第二个就会包含你的第一个和第二个commit。 在分支上工作允许你将pull request从彼此之间分离开来。 至于如何称呼你自己的分支那就取决于你自己了。 一些人喜欢在分支名里面包含issue号，也有些人喜欢使用等级结构来进行命名。","title":"分支"},{"location":"/2018/workingWithGit.html#squash-压缩-提交","text":"我们倾向于每一个pull request都是一个单独的提交。理由如下：\n回滚单个提交到稳定分支比回滚一组提交更加简单，并且出错的概率更小。 如果变更只在一个提交里面 ，回滚就根本没有机会污染分支，不管整个变更是不是cherry pick过来的。 我们的目标在于master分支永远都是可以发布的状态， 而这包括历史上的每个点都是可发布，而不仅仅是现在而已。 如果我们需要回滚某个提交的话，我们必须确信在这个提交之前的分支状态是稳定并且可发布的。 如果变更都是在一个提交里面的话，这有助于我们在历史纪录里面回溯变更的内容。\n当然，也存在着不适合使用squash的场景，但是这些都应该根据场景进行逐个分析。 下面列举了一些我们并不要求压缩提交的例子：\n当pull request里面包含着多于一个人的提交的时候。在这个场景里面，我们倾向于同一个人的所有提交都是squash的。 当pull request来自于被社区内部共享的fork或者分支的时候。这时候如果重写变更记录会导致从这个fork或者分支拉取变更的人遇到问题。 当pull request包含非常大的工作量的时候，提交记录会有助于理解工作的演化。\n但是，在大多数情况下，如果你的pull request包含多个提交的话，那么你需要按照如下步骤进行操作：\n确保你的repo包含核心master分支的所有变更： git fetch origin\n 开始进行一个交互式的rebase: git rebase -i origin/master\n 这个命令会在你的编辑器里面打开一个屏幕，允许你讲述你在每个提交里面做了什么。如果第一个提交的提交信息适用于描述所有提交，那么就可以保留它，否则就将它之前的命令从pick改成reword. 对于剩下的每个提交，将命令从pick改成fixup。这会告诉git将每一个提交合并到之前的提交里面去，并使用之前提交的commit message. 保存文件之后退出编辑器。Git会开始rebase的操作。如果你reword了第一个提交，那么git会给你打开一个编辑器来让你填入新的提交信息。如果填完了以后一切正常，那么工作就完成了。但是在将你的变更应用到最新的master分支的时候，可能会发生冲突，那么这个时候你就需要解决冲突，然后运行命令： git rebase --continue\n如果含有冲突的变更很多，那么也许这个步骤需要被重复很多次。 6. 好了，现在你应该已经rebase好了，这个时候就要推送你的所有变更了。如果你在squash之前已经提交过了分支（包含你已经创建了pull request的场景），那么你就需要做一个强制推送。可以通过如下命令来完成：\ngit push yourremote yourbranch --force","title":"Squash（压缩）提交"},{"location":"/2018/workingWithGit.html#响应评审意见或者构建失败","text":"如果你的pull request没有通过CI构建，或者如果我们在代码评审之后告知你需要更新你的pull request，或者如果有任何其他你需要更新你的pull request的理由，那么与其创建一个新的提交，不如改进已有的。这个操作可以通过提交的时候使用--amend标志来完成：\ngit commit --amend\namend完成之后，我们又一次需要通过强制提交标志--force来进行提交：\ngit push yourremote yourbranch --force","title":"响应评审意见或者构建失败"},{"location":"/2018/workingWithGit.html#重新开始","text":"有时有人发现他们的pull request完全错了，然后想重新开始。这样也可以，但是没有必要关闭原来的pull request然后起一个新的。你可以使用强制推送来将一个全新的分支推送到这个pull request里面。\n重新开始之前，确保你已经获取核心仓库的最新变更，然后从那一个点创建一个新的分支：\ngit fetch origin\ngit checkout -b mynewbranch origin/master\n然后在这个分支上进行你的工作。当你准备好了要提交pull request的时候，假设你的老的分支名是myoldbranch，将你的新的分支强制推送到你的仓库里面的老的分支里面去：\ngit push yourremote mynewbranch:myoldbranch --force\n这之后，pull request会更新成你的新的分支。","title":"重新开始"},{"location":"/2018/workingWithGit.html#关于变更记录","text":"也许你听说过这么一个说法，就是你不应该在发布之后修改git的历史纪录。但是使用rebase和commit --amend都会修改变更记录，而使用push --force会发布你的整个变更记录。\n当然存在着发布之后不应该修改git历史纪录的情况，尤其是在其他人fork了你的仓库，或者从你的仓库拉取了更新的时候。 这个时候修改变更记录的话会使得其他人没有办法安全地将你在仓库里面的变更合并到他们自己的仓库里面去。基于这个理由，需要被贡献代码的核心仓库永远不应该修改自己的历史纪录。\n然而，当你在自己的私人fork里面的时候，或者在只是为了pull request而创建的分支上时，情况就完成不一样了。 这个工作流程的本质是你的变更在合并到master分支的时候才是真正地“被发布”。在此之前，你想怎样折腾你的分支都是可以的。\n当然，如果你的分支是很多人协作的，并且你相信其他人有很好的理由从你的分支进行拉取。那么这个时候请让管理核心开发库的人员悉知。这个时候，就不应该强制要求你的pull request是压缩了的提交，因为这样做并不合理。","title":"关于变更记录"}]}