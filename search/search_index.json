{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Wayne的博客"},{"location":"/index.html#wayne的博客","text":"","title":"Wayne的博客"},{"location":"/index.html#简介","text":"欢迎来到我的博客。本网站使用Lightbend Paradox构建，主要内容会与Scala技术栈相关。偶尔也会穿插一些琐话。欢迎关注我的公众号以及时获得更新信息。","title":"简介"},{"location":"/index.html#目录","text":"2018年8月 使用Paradox构建文档网站","title":"目录"},{"location":"/2018/index.html","text":"","title":"2018年8月"},{"location":"/2018/index.html#2018年8月","text":"使用Paradox构建文档网站","title":"2018年8月"},{"location":"/2018/paradox_site_setup.html","text":"","title":"使用Paradox构建文档网站"},{"location":"/2018/paradox_site_setup.html#使用paradox构建文档网站","text":"","title":"使用Paradox构建文档网站"},{"location":"/2018/paradox_site_setup.html#lightbend-paradox简介","text":"Lightbend Paradox是为了软件项目文档而开发的Markdown文档工具。它提供了开箱即用的基本样式、完善的Github Flavor Markdown语法支持，并且可以通过指定的方法进行代码片段引入。结合sbt-site插件，可以非常轻松地做到在本地一键发布博客的过程，或者是通过Github的Travis CI在commit之后进行自动构建发布。对于Scala程序员来说，Paradox最大的好处在于可以使得代码和文档不被割裂。你的文档可以直接放在项目里面，然后通过特定语法将代码引入到文档中，从而使得文档内容可以在IDE里面随着代码变更直接变动，而不需要上下文切换到浏览器这个新环境中进行编写。\n上周我将Paradox引入了自己正在开发的项目里，并且第一次感受到了写文档的乐趣。之后便萌生想法，想要使用Paradox来构建自己的博客。当然，对于博客来说，这个组件并非最好的。但是用来做一些基本的思考记录还是足够的。Paradox最好的归宿是用来做文档网站，结合Github pages，可以轻松地做到版本相关的文档发布。目前基本上Lightbend除了基于Playframework构建的项目是使用早就存在的PlayDocPlugin之外，其他相关的项目都是使用的Paradox来做文档管理，如Akka，Alpakka等，尤其是一些小项目，结合Github pages，相当方便。本篇将介绍如何使用Paradox快速构建文档项目。","title":"Lightbend Paradox简介"},{"location":"/2018/paradox_site_setup.html#sbt配置paradox","text":"在project/plugins.sbt中添加插件：\naddSbtPlugin(\"com.lightbend.paradox\" % \"sbt-paradox\" % \"0.4.0\")\nFull source at GitHub\n在build.sbt中定义项目：\nlazy val docDemo = (project in file(\"docs\")).\n  enablePlugins(ParadoxPlugin).\n  settings(\n    name := \"Demo Project\",\n    paradoxTheme := Some(builtinParadoxTheme(\"generic\"))\n  )\nFull source at GitHub\n之后，你只需要在docs/src/main/paradox中创建index.md文档即可：\n# 示例文档\n\n本文档由Paradox生成。\n\n## 这是会出现在右侧的二级标题\nFull source at GitHub\n然后执行sbt命令paradox，就能在docs/target/paradox/site/main中找到index.html文件，以及其他css和js文件。之后直接浏览器打开index.html即可:\n如果你拿这个页面对比一下Alphakka的文档样式，你会发现两者几乎完全一样，只是Alphakka多了一个Akka的标志而已。\nParadox的所有源文件都是使用的Markdown语法来书写。并且因为与Github结合紧密，所以其采用了Github-flavored风格。它背后的Markdown解析器是由Mathias开发的Pegdown(这哥们儿最有名的库是后来发展成为Akka-http的Spray)。当然，虽然这个库已经不再维护了，但是用来做这里的语法解析也是绰绰有余的。\n到现在我们的文档网站已经做好了。之后便需要按照需求来组织一下页面即可。","title":"Sbt配置Paradox"},{"location":"/2018/paradox_site_setup.html#页面组织","text":"所有页面的第一个标题会成为该页面的标题，不管该标题的级别是什么。页面树是通过在Markdown文档中嵌入用@@@ index容器包裹的内容来解析的。格式如下：\n@@@ index\n\n* [设置](setup/index.md)\n* [用途](usage/index.md)\n\n@@@\nFull source at GitHub\n这里的页面是一个树状的结构。你可以在后面的setup/index.md中继续使用相同的语法进行页面扩展。但是左侧的页面树默认最多只有两级。而且，如果不做特别处理的话，在当前页面是看不到页面树的。不过你可以通过在页面中添加指令\n@@toc { depth=1 }\nFull source at GitHub\n如此之后，在当前页面就也能看到页面层次了。其中depth的设置可以改变页面树的级数。\n以此类推，我们就能构建组织出一个文档项目的完整、清晰的结构。","title":"页面组织"},{"location":"/2018/paradox_site_setup.html#片段引入","text":"Github的Markup有个著名的issue#346，其中维护者明确地拒绝了在Github Markdown中添加嵌入文件片段的请求，而不顾几百个+1的请求。这个需求说实话，确实是个刚需，所以Paradox为我们贴心地做了一下实现。通过以下语法，可以将位于src/main/scala/HelloApp.scala里面的包含在// #hello-example中间的代码片段引入本文件：\n@@snip [HelloApp.scala](../../scala/HelloApp.scala) { #hello-example }\n代码源文件为：\n// #hello-example\nobject HelloApp extends App {\n  println(\"Hello, world!\")\n}\n// #hello-example\n页面中则是如下格式：\nobject HelloApp extends App {\n  println(\"Hello, world!\")\n}\nFull source at GitHub\n注意，不管是什么样的文件，只要文件名、路径对上，Paradox都能帮我们做引入，例如我上面的markdown文档片段就是直接从本docDemo项目的文档中引入进行来的。\n至此，我基本把Paradox里面的主要会用到的内容讲完了。后续如果需要做更多定制化的内容，大家可以直接去看官网文档，包括如何使用本博客采用的主题方式\n接下来我们讲如何使用sbt-site插件","title":"片段引入"},{"location":"/2018/paradox_site_setup.html#sbt-site插件的使用","text":"这些程序员一般都很懒，能代码做掉的事情绝对不手动去做。如果我们只使用paradox的话，我们需要执行sbt命令paradox之后，将生成在target/paradox/site/main里面的文件手动git add和commit到Github上面去，才能发布网站。而为了解决这个多好多步的问题，我们使用sbt-site插件，来让我们只需要执行ghpagesPushSite命令，即可一键发布。\n首先还是添加插件。在project/plugins.sbt中添加：\naddSbtPlugin(\"com.typesafe.sbt\" % \"sbt-site\" % \"1.3.2\")\n\naddSbtPlugin(\"com.typesafe.sbt\" % \"sbt-ghpages\" % \"0.6.2\")\nFull source at GitHub\n其中sbt-site是帮助我们打包网站，sbt-ghpages则帮助我们发布到Github的gh-pages分支。\nNote 注意，加入sbt-site插件之后，之前Paradox指引的类似在build.sbt文件中添加到Compile的属性现在要添加到Paradox才能生效，如： paradoxProperties in Paradox ++= Map(\n  \"github.base_url\" -> s\"https://github.com/WayneWang12/Waynewang12.github.io/tree/blog\",\n  \"snip.project.base_dir\" -> (baseDirectory in ThisBuild).value.getAbsolutePath\n),Full source at GitHub 另外，为了使我们的源文件还是在src/main/paradox里面，你需要在项目中进行如下设定： sourceDirectory in Paradox := sourceDirectory.value / \"main\" / \"paradox\",\n\nsourceDirectory in Paradox in paradoxTheme := sourceDirectory.value / \"main\" / \"paradox\" / \"_template\",\nFull source at GitHub 否则，默认的源文件夹是src/paradox。\n之后，我们需要在build.sbt文件中设置发布文档项目到的目的仓库。例如，本博客的设置为：\nscmInfo := Some(ScmInfo(url(\"https://github.com/WayneWang12/WayneWang12.github.io.git\"), \"git@github.com:WayneWang12/WayneWang12.github.io.git\")),\ngit.remoteRepo := scmInfo.value.get.connection,\nname := \"Wayne's Blog\",\nghpagesBranch := \"master\",\nFull source at GitHub\n注意最后一行的ghpagesBranch := \"master\"。在Github上形如username.github.io的仓库默认是个人主页的主项目，所以这个项目中无法设置gh-pages这个分支，而必须是master。所以这里我做了改变。但是如果是其他项目的话，则可以不加这一行。例如，假如我有一个sbt-site的项目，在gh-pages分支设置好了以后，我就可以通过http://waynewang12.github.io/sbt-site来访问它了。\n上述设置完成以后，我们接下来需要做一次初始化设置：\nsbt clean make-site                             # <1> Build the site\norigin=$(git remote get-url origin)             # <2> Save the current remote for later\ncd target/site\ngit init                                        # <3> Create site repo and add initial content\ngit add .\ngit commit -m \"Initial import of GitHub Pages\"\ngit push --force \"$origin\" master:gh-pages      # <4> Publish the repo's master branch as gh-pages\n注意，如上所说，最后一行的gh-pages你需要根据你的项目性质做改变。例如，本博客的源代码就在blog分支，而Github pages内容则在master分支。所以第四步我执行的是：\ngit push --force \"$origin\" blog:master      # <4> Publish the repo's master branch as gh-pages\n这一次完成了之后，每次我需要发布新内容，就只需要执行sbt命令\nghpagesPushSite\n就可以发布新内容了。","title":"sbt-site插件的使用"},{"location":"/2018/paradox_site_setup.html#总结","text":"怎么样，对于基于sbt构建项目的Scala程序员来说，是不是很简单，很方便？最棒的一点是你可以将编译通过的代码直接引入到文档里面去，之后就算代码做了变更，文档内容也会随之变更，而不会出现代码改了文档没改的尴尬情形。并且因为所有的一切都在IDE里面完成，程序员完全不需要进行场景切换，所以效率会更高，也更有动力去编写文档。\n所以，十分推荐有文档需求的Scala程序员来尝试一下本插件。并且自行琢磨出一套文档和代码一起持续演进的流程，来与大家分享。","title":"总结"}]}