<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="wayne-blog">
<meta name="generator" content="Paradox, paradox-material-theme=0.5.0-SNAPSHOT, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="wayne-blog">
<link rel="shortcut icon" href="../favicon.ico">
<title>第四届阿里中间件性能大赛初赛RDP飞起来团队总结 · Wayne的博客</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
<meta name="theme-color" content="#3f51b5" />
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-4943945761370753",
enable_page_level_ads: true
});
</script>
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
data-md-color-primary="indigo"
data-md-color-accent="light-blue"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Wayne的博客" class="md-header-nav__button md-logo">
<i class="md-icon">timeline</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Wayne的博客
</span>
<span class="md-header-nav__topic">
第四届阿里中间件性能大赛初赛RDP飞起来团队总结
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/WayneWang12/WayneWang12.github.io"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
WayneWang12/WayneWang12.github.io
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Wayne的博客" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">timeline</i>
</a>
<a href="../index.html" title="Wayne的博客">
Wayne的博客
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/WayneWang12/WayneWang12.github.io"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
WayneWang12/WayneWang12.github.io
</div>
</a>

</div>
<ul>
  <li><a href="../2018/index.html" class="page">2018年</a>
  <ul>
    <li><a href="../2018/paradox_site_setup.html" class="page">使用Paradox构建文档网站</a></li>
    <li><a href="../2018/workingWithGit.html" class="page">使用Git的一些原则</a></li>
    <li><a href="../2018/pricinpleOfReactiveStream.html" class="page">反应式流回压的原理</a></li>
    <li><a href="../2018/middleware_race_preliminary.html" class="active page">第四届阿里中间件性能大赛初赛RDP飞起来团队总结</a></li>
    <li><a href="../2018/jmh.html" class="page">应用JMH测试大型HashMap的性能</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../2018/middleware_race_preliminary.html#第四届阿里中间件性能大赛初赛rdp飞起来团队总结" class="header">第四届阿里中间件性能大赛初赛RDP飞起来团队总结</a>
  <ul>
    <li><a href="../2018/middleware_race_preliminary.html#赛题背景分析及理解" class="header">赛题背景分析及理解</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#题目分析" class="header">题目分析</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#核心思路" class="header">核心思路</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#关键代码" class="header">关键代码</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#比赛经验总结和感想" class="header">比赛经验总结和感想</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.1
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../2018/middleware_race_preliminary.html#第四届阿里中间件性能大赛初赛rdp飞起来团队总结" class="header">第四届阿里中间件性能大赛初赛RDP飞起来团队总结</a>
  <ul>
    <li><a href="../2018/middleware_race_preliminary.html#赛题背景分析及理解" class="header">赛题背景分析及理解</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#题目分析" class="header">题目分析</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#核心思路" class="header">核心思路</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#关键代码" class="header">关键代码</a></li>
    <li><a href="../2018/middleware_race_preliminary.html#比赛经验总结和感想" class="header">比赛经验总结和感想</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h2><a href="#第四届阿里中间件性能大赛初赛rdp飞起来团队总结" name="第四届阿里中间件性能大赛初赛rdp飞起来团队总结" class="anchor"><span class="anchor-link"></span></a>第四届阿里中间件性能大赛初赛RDP飞起来团队总结</h2>
<p>国庆刚刚好在弄阿里云组织的第一届POLARDB数据库性能大赛，忽然想起来可以把我之前写的阿里中间件比赛的总结发到博客里面。这一篇已经被几个公众号发过了，包括阿里中间件官方号。内容主要是如何使用akka来构建一个高性能的适配Dubbo的Service Mesh Sidecar。当然我的分数主要是通过Netty拿的。但是其实Netty只是胜在可以Zero Copy这一点上，贴近底层，没有什么意思。Akka构建Agent才包含更多的反应式思想。</p>
<h3><a href="#赛题背景分析及理解" name="赛题背景分析及理解" class="anchor"><span class="anchor-link"></span></a>赛题背景分析及理解</h3>
<p>初赛题目是吸引我参加比赛的最大原因。其中一段描述了Service Mesh的作用:</p>
<blockquote>
  <p>作为 Service Mesh 的核心组件之一，高性能的服务间代理（Agent）是不可或缺的，其可以做到请求转发、协议转换、服务注册与发现、动态路由、负载均衡、流量控制、降级和熔断等诸多功能，也是区别于传统微服务架构的重要特征。</p>
</blockquote>
<p>而这种思想与《反应式设计模式》不约而同。在反应式系统设计的过程中，很重要的一块就是如何与现存的非反应式系统进行交互。非反应式系统典型地都具有同步阻塞调用者、无界输入队列、不遵循有界响应延迟的原则等缺点，这使得流量控制、资源高效利用以及降级、熔断等功能都比较难以实现。《反应式设计模式》一书中专门推荐了要使用单独的资源来与这些系统整合，并赋予他们“反应式”的假象。而Service Mesh中的Agent，则可以看作成专门用来与非反应式系统进行整合的组件。在第14章的资源管理模式中，描述了如何使用这样的资源与之进行交互的方法，尤其是托管阻塞模式；而第16章的流量控制模式，则指导了我们如何在调用过程中行之有效进行流量控制。当然，对于比赛来说，这些设计相对来说过于概括。不过我们可以先基于这种概括性的原则构建出体系架构，之后我们再具体优化相关的细节，提高成绩。而基于之前描述的原因，我的第一版使用了Akka来进行开发。接下来我们先分析一下具体的题目。</p>
<h3><a href="#题目分析" name="题目分析" class="anchor"><span class="anchor-link"></span></a>题目分析</h3>
<p>题目的要求是：</p>
<blockquote>
  <p>实现一个高性能的 Service Mesh Agent 组件，并包含如下一些功能： 1. 服务注册与发现 2. 协议转换 3. 负载均衡 </p>
</blockquote>
<p>服务注册与发现是为了获得资源的访问方式。这个过程最好不要与正式的调用过程耦合。所以我们用一个单独的Actor来做服务发现。如果是在Consumer中，这个Actor会去监听ETCD的变更，如果发现Endpoints发生了变化，则将信息发布到ActorSystem的事件流中。之后关注<code>EndpointsUpdated</code>事件的Actor就会收到此消息，并根据它来更新自己的端点列表，进行负载的动态变更。</p>
<p>协议转换相对来说是一个打铁的活，根据Dubbo协议一点点写好就行了。</p>
<p>重要的则在于负载均衡。进一步回到题目描述中：</p>
<blockquote>
  <ol>
    <li>每轮评测在一台服务器中启动五个服务（以 Docker 实例的形式启动），一个 etcd 服务作为注册表、一个 Consumer 服务和三个 Provider 服务；</li>
    <li>使用一台独立的施压服务器，分不同压力场景对 Consumer 服务进行压力测试，得到 QPS；</li>
  </ol>
</blockquote>
<p>总共有3轮压力测试，分别是128、256、512个连接。由于每次请求的往返时间最少也是50ms，那么每秒钟，按照512连接的最大速度，则是1000 / 50 * 512 = 10240的最大QPS。</p>
<p>其中，三台Provider的负载能力有所不同，按照CPU的quota分配以及内存的大小分配，正常情况下应该是1比2比3。只是由于Provider的dubbo端最多同时只能处理200个请求，多出来的直接被reject掉。那么最好的分配比例在512条件下则是 <code>112 : 200 : 200</code>。</p>
<p>当然，根据我们之前说的反应式流回压的原理，反应式系统的设计原则并不是固定分配比例的。它希望的理想情形是<code>你告诉我你想要处理多少任务，一旦任务来了，我就尽量按照这个数量发给你</code>。不要Consumer去强行推，不要Provider一直来拉。而这种模式最好的实现方式，就是利用Akka Stream。只不过，由于我们的工作其实是跨系统的，而Akka并没有在其TCP连接实现按照处理能力进行的回压机制，而是通过网络连接的缓冲区Buffer是否溢出而进行的回压，所以并非完美的反应式流机制。后续深入研究的时候我才知道了RSocket协议的存在以及<a href="https://github.com/rsocket/rsocket-java">rsocket-java</a>。有兴趣的同学可以调研一下其性能。</p>
<p>下面我们继续说比赛的内容。</p>
<h2><a href="#核心思路" name="核心思路" class="anchor"><span class="anchor-link"></span></a>核心思路</h2>
<p>按照前面的分析，核心思路就是将每个Provider的处理过程看作是一条流。来自调用端的所有请求先汇聚到一个队列里面，之后根据后端Provider的处理能力，分别分配到三个不同的流中。而如果汇聚队列的长度达到了界限值，则降级服务，对外部请求进行按比例丢弃，直到与系统的处理能力重新匹配（详情参见《反应式设计模式》第十六章丢弃模式）。这样整个系统就又健壮又迅速。</p>
<h2><a href="#关键代码" name="关键代码" class="anchor"><span class="anchor-link"></span></a>关键代码</h2>
<p>下面一段是用来抽象Consumer的Actor里面的代码，所有连接的请求都被注册到RequestHandler这个Actor了。</p>
<pre class="prettyprint"><code class="language-scala">  val requestHandler: ActorRef = context.actorOf(Props(new RequestHandler).withDispatcher(&quot;mpsc&quot;), &quot;request-handler&quot;)

  def receive: Receive = {
    case Bound(localAddress) ⇒
      etcdManager ! &quot;consumer&quot;
      log.info(s&quot;service started at ${localAddress.getHostString}:${localAddress.getPort}&quot;)
    case CommandFailed(_: Bind) ⇒
      context stop self
    case Connected(_, _) ⇒
      val connection = sender()
      connection ! Register(requestHandler) 
      //将Connection全部注册到RequestHandler，就是说所有连接发过来的数据都回转发到这个Actor
      //注意这个是Hack写法。正统的还是应该一个Actor一个连接，这样逻辑才会清晰。
  }
</code></pre>
<p>然后在<code>Requesthandler</code>里面，接收到的<code>ByteString</code>直接作为元素提供给后面的处理流代码里面。</p>
<pre class="prettyprint"><code class="language-scala">  var source: SourceQueueWithComplete[(Long, ByteString)] = _
  
  override def receive: Receive = {
    case Received(bs) =&gt;
      source.offer(sender().path.name.toLong, bs) //这里的sender是处理连接的actor，它们的名字刚刚好是ID，所以直接复用。
    case EndpointsUpdate(newEndpoints) =&gt;
      log.info(s&quot;start new source for endpoints $newEndpoints&quot;)
      source.complete()
      source = getSourceByEndpoints(newEndpoints)
</code></pre>
<p>这里的<code>source</code>是一个可完成<code>Source</code>。<code>Source</code>, <code>Flow</code>, <code>Sink</code>是Akka Stream里面的基本构建块。其大体意义如下：</p>
<ol>
  <li>Source: 只有一个输出流的构件块;</li>
  <li>Sink: 只接收一个输入流的构件块;</li>
  <li>Flow: 接收一个输入流，并拥有一个输出流的构件块。</li>
  <li>Graph: 一个打包好的流处理拓扑，它可以拥有一组输入端口或者输出端口。</li>
</ol>
<p>我们这里是一个<code>SourceQueueWithComplete</code>，它由<code>Source.queue</code>声明并物化后产生：</p>
<pre class="prettyprint"><code class="language-scala">  def getSourceByEndpoints(endpoints: Set[Endpoint]): SourceQueueWithComplete[(Long, ByteString)] = {
    val handleFlow = Flow[(Long, ByteString)]
      .via(DubboFlow.connectionIdFlow)
      .via(endpointsFlow(endpoints))
      .to(DubboFlow.decoder)
      
    Source.queue[(Long, ByteString)](512, OverflowStrategy.backpressure)
      .to(handleFlow).run()
  }
</code></pre>
<p>这里是由这个函数基于<code>Endpoint</code>的个数构建。第一段<code>handleFlow</code>是构建了一个<code>Flow</code>，这个<code>Flow</code>可以接收一个二元组<code>(Long, ByteString)</code>，并将其交给<code>DubboFlow.connectionIdFlow</code>来encode成自定义协议，之后将其发送到<code>endpointsFlow</code>进行对Provider的调用，并得到结果。得到结果之后，经由<code>DubboFlow.decoder</code>来decode，并发送回给各个连接Actor，由其返回给客户端。</p>
<p>上面的内容里面，<code>DubboFlow.connectionIdFlow</code>和<code>DubboFlow.decoder</code>不多说，都是打铁代码。核心逻辑<code>endpointsFlow(endPoints)</code>贴出如下：</p>
<pre class="prettyprint"><code class="language-scala">  def endpointsFlow(endpoints: List[Endpoint]) = {
    
    val tcpFlows = endpoints.map { endpoint =&gt;
      Tcp().outgoingConnection(endpoint.host, endpoint.port).async
    }
    
    val framing = Framing.lengthField(4, 12, Int.MaxValue, ByteOrder.BIG_ENDIAN)

    Flow.fromGraph(GraphDSL.create(tcpFlows) { implicit builder =&gt;
      tcpFlows =&gt;
        import GraphDSL.Implicits._
        
        val balance = builder.add(Balance[ByteString](tcpFlows.size))
        val bigMerge = builder.add(Merge[ByteString](tcpFlows.size))
        tcpFlows.foreach { tcp =&gt;
          balance  ~&gt; tcp ~&gt; framing ~&gt; bigMerge
        }
        
        FlowShape(balance.in, bigMerge.out)
    })
  }
</code></pre>
<p>每一个<code>endpoint</code>都被映射成为一个<code>Tcp</code>的<code>Flow</code>，通往Provider端。之后使用Akka Stream的DSL方法，构建了一个<code>Graph</code>。这个<code>Graph</code>用图形表示，其拓扑结果则是如下：</p>
<pre><code>                      +------&gt; Small Provider +--------&gt; Framing +-------+
                      |                                                  |
    Input             |                                                  |                Output
+--------&gt; Balancer ---------&gt; Medium Provider+--------&gt; Framing +----------------&gt; Merge +--------&gt;
                      |                                                  |
                      |                                                  |
                      +------&gt; Large Provider +--------&gt; Framing +-------+
</code></pre>
<p>数据由左边输入，经过Balancer，这个Balancer是由Akka Stream提供的现成组件，它可以将上游的元素路由到下游，其特性如下：</p>
<ol>
  <li>一个<code>Balance</code>由一个<code>in</code>端口和2到多个<code>out</code>端口，</li>
  <li>当任意下游端口停止回压之后，它输出元素到下游输出端口；</li>
  <li>当下游所有端口都在回压的时候，它就回压上游；</li>
  <li>当上游完成时，它也完成；</li>
  <li>当其<code>eagerCancel</code>参数设置为<code>true</code>时，任意下游取消，则其也取消；设置为<code>false</code>的时候，当所有下游取消，它才取消。</li>
</ol>
<p>由上面的拓扑结构可以看到，当任意Provider向上游表示可以处理请求的时候，Balancer就会在有请求到来的时候，向其输出；Provider处理完的请求，经过TCP拆包过程之后，就合并到一起，交由下游的流继续处理。如此，只要连接有请求过来，那么整个流就能一直运转。这个过程中，即使某个通往provider的连接断掉了，Balancer也能继续将请求路由到其他两个连接上。而这个时候，负责服务发现的Actor就会发出<code>EndpointsUpdated</code>的消息，此时<code>RequestHandler</code>会进入第二个匹配，用新的Endpoint来更新我们的处理流：</p>
<pre class="prettyprint"><code class="language-scala">    case EndpointsUpdate(newEndpoints) =&gt;
      log.info(s&quot;start new source for endpoints $newEndpoints&quot;)
      source.complete()
      source = getSourceByEndpoints(newEndpoints)
</code></pre>
<p>注意这里的<code>complete</code>是表示流不再接收新的请求，这之前已经入队的请求仍然会继续完成，直到全部处理完毕。</p>
<p>Provider的代码相对Consumer就简单很多：</p>
<pre class="prettyprint"><code class="language-scala">  val handleFlow = Tcp().outgoingConnection(host, dubboPort).async

  def startService: Future[Done] = {
    Tcp().bind(host, port).runForeach { conn =&gt;
      conn.handleWith(handleFlow)
    }
  }
</code></pre>
<p>它只需要将Consumer过来的连接转发给后端的Dubbo，或者为了性能原因，它需要将自定义协议包装成Dubbo协议，然后发过去，再将结果转回，即可。</p>
<p>到这里，我们用了大约不到300行代码，就完成了初赛题目的所有要求。并且代码的普适性和健壮性都很不错，后续还能依据需求，快速地实现任意一端的限流要求(<code>Flow[Request].throttle(...)</code>)，或者加入断路器，进行快速失败。</p>
<p>这套代码在CPU资源充足的时候，例如在我本地(注意，已经按照docker参数限定了CPU quota和内存)，256连接的时候可以跑4960, 512的时候可以跑9500。</p>
<p>然而线上则表现不好，分别最多4500和6400。这是为什么呢？</p>
<p>经过查询源码以后发现，问题出现在这一段：</p>
<pre class="prettyprint"><code class="language-scala">@tailrec def innerRead(buffer: ByteBuffer, remainingLimit: Int): ReadResult =
        if (remainingLimit &gt; 0) {
          // never read more than the configured limit
          buffer.clear()
          val maxBufferSpace = math.min(DirectBufferSize, remainingLimit)
          buffer.limit(maxBufferSpace)
          val readBytes = channel.read(buffer)
          buffer.flip()

          if (TraceLogging) log.debug(&quot;Read [{}] bytes.&quot;, readBytes)
          if (readBytes &gt; 0) info.handler ! Received(ByteString(buffer)) //这一段

          readBytes match {
            case `maxBufferSpace` ⇒ if (pullMode) MoreDataWaiting else innerRead(buffer, remainingLimit - maxBufferSpace)
            case x if x &gt;= 0      ⇒ AllRead
            case -1               ⇒ EndOfStream
            case _ ⇒
              throw new IllegalStateException(&quot;Unexpected value returned from read: &quot; + readBytes)
          }
        } else MoreDataWaiting
</code></pre>
<p>其中<code>info.handler ! Received(ByteString(buffer))</code>是将<code>SocketChannel</code>接收到的数据复制成<code>ByteString</code>类型之后，再发送出去的，所以相当于是从堆外把数据复制了进来，于是整个流程都不是zero copy的。本来在正常的应用场景下，不ZC是必然的，因为应用服务器肯定要把数据读出来进行处理。但是在本次比赛的场景以及作为Proxy的情况下，这种复制就是非常昂贵的操作了，直接导致Akka版本的代码无法和Netty竞争，即使代码再精简，思想再精妙，也无法取得好的成绩。所以在第二个版本中，我换用了Netty来跑分。</p>
<p>Netty版本下的核心代码，分ConsumerAgent和调用PrivderAgent的NettyClient列出如下：</p>
<p>ConsumerAgent:</p>
<pre class="prettyprint"><code class="language-scala">  override def channelRead(ctx: ChannelHandlerContext, msg: scala.Any): Unit = {
    msg match {
      case in: ByteBuf =&gt;
        val meshRequest = MeshRequest(cid) //cid是connectionId,在连接建立的时候获取
        val maybeClient = ClientChannelHolder.clientChannelCache.get() //client的channel存在了ThreadLocal里面，直接通过ThreadLocal获取到channelHandler
        maybeClient.writeAndFlush(meshRequest.toCustomProtocol(in), maybeClient.voidPromise()) //将流入的bytebuffer转变成自定义协议的格式，并直接向client的channel刷入数据
        meshRequest.recycle //回收MeshRequest对象
    }
  }
 
</code></pre>
<p>NettyClient:</p>
<pre class="prettyprint"><code class="language-scala">override def channelRead(ctx: ChannelHandlerContext, msg: scala.Any): Unit = {
          msg match {
            case bs: ByteBuf =&gt;
              val cid = bs.getLong(4) //从ByteBuffer中获取connectionId
              val resp = MeshResponse(cid) //包装成MeshResponse
              val ch = ServerChannelHolder.serverChannelMap.get().get(cid) //根据connectionId获取这个连接的SocketChannel
              if(ch != null) { //如果存在的话，则刷入响应
                ch.writeAndFlush(resp.toHttpResponse(bs), ch.voidPromise())
              }
              resp.recycle //回收MeshResponse对象
          }
        }
</code></pre>
<p>这个是我所发现的最短的路线。其中省略了路由的过程。整体的线程设置如下：</p>
<pre class="prettyprint"><code class="language-scala">  val acceptorGroup = new EpollEventLoopGroup(1)
  val threadFactory = new DefaultThreadFactory(&quot;atf_wrk&quot;)
  val workerNumber = 3
  val workerGroup = new EpollEventLoopGroup(workerNumber, threadFactory)
</code></pre>
<p>一个负责IO的线程，三个负责处理请求的线程。三个NettyClient分别使用三个worker中的一个就好了：</p>
<pre class="prettyprint"><code class="language-scala">  val eventLoop = workerGroup.next()
  new NettyClient(ed.host, ed.port, eventLoop, 1, ed.scale)
</code></pre>
<p>主要的trick就是我只起了4个线程，1个负责IO，3个负责请求处理。通过连接绑定的线程来进行路由，所以少了很多人加权轮询的步骤，而且每个连接只通过同一个线程进行流转，所以也少了context switch的过程。情况好的话，4个线程应该pin到它们的cpu上，没有任何的上下文切换。</p>
<p>至于其他就是一些打铁的小细节，比如使用Recycler生成对象池来回收对象，使用池化的ByteBuf来避免堆外内存分配的开销，预先定义好一些要用来包装请求和回复的对象，使用<code>Unpooled.unreleasableBuffer(buffer)</code>来反复利用。如此，整个过程下来，不会有FGC，而YGC最多也就两三次而已。Recycler的代码列出如下：</p>
<pre class="prettyprint"><code class="language-scala">class MeshRequest private(handle: Handle[MeshRequest]) {
  private var cid: Long = _
  private var buffer: ByteBuf = _
  private var composite: CompositeByteBuf = _

  def recycle = {
    cid = 0l
    buffer = null
    composite = null
    handle.recycle(this)
  }

  def toCustomProtocol(bb: ByteBuf) = {
    val n = bb.indexOf(280, bb.readableBytes(), &#39;=&#39;.toByte)
    val parameter = bb.skipBytes(n + 1)
    buffer.writeLong(cid)
    buffer.writeInt(parameter.readableBytes())
    composite.addComponents(true, buffer, parameter)
  }

}

object MeshRequest {
  private val RECYCLER = new Recycler[MeshRequest]() {
    override def newObject(handle: Recycler.Handle[MeshRequest]): MeshRequest = {
      new MeshRequest(handle)
    }
  }

  def apply(id: Long): MeshRequest = {
    val request = RECYCLER.get()
    request.cid = id
    request.buffer = ConsumerAgent.allocator.directBuffer(12)
    request.composite = ConsumerAgent.allocator.compositeBuffer()
    request
  }
}
</code></pre>
<p>最终，Netty版本的代码停留在6894，而Akka版本我没记错的话，应该是6400左右。</p>
<h2><a href="#比赛经验总结和感想" name="比赛经验总结和感想" class="anchor"><span class="anchor-link"></span></a>比赛经验总结和感想</h2>
<p>其实是第一次参加这种编程的比赛，开始的时候看得蛮轻，因为按照一般的生产场景来说，我的第一种方案已经足够好了，编码简单、健壮、可扩展性强，应该是能够出彩的。但是因为比赛的场景和需求不同，所以非ZC的方案没办法取得好的成绩，所以后续不得已，只能放弃Akka，使用Netty写了一个版本的打铁代码，以往前冲击一个比较好的名次，然后争取机会来向大家吹嘘Akka。事实证明，限定场景来做极致优化的话，Netty确实好很多，不过，在通用场景下，用Akka Stream的思想，则可以迅速构建出一个集各种流控功能于一体，也非常好扩展，并且性能也不会相差太多的组件。所以，不管怎样，到最终的总结还是，如果是需要读取出数据的应用服务场景下，我来开发的话，Akka和Akka Stream绝对会是主力，而Netty则可以被应用在不需要将数据读出内存的场景(如只负责转发或者解析自定义协议的Provider端)。两者相结合，应该可以达到比较好的平衡。</p>
</div>
<div>
<a href="https://github.com/WayneWang12/Waynewang12.github.io/tree/master/src/main/paradox/2018/middleware_race_preliminary.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1
</span>
</div>
</article>
<div id="comments"></div>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../2018/pricinpleOfReactiveStream.html" title="反应式流回压的原理" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
反应式流回压的原理
</span>
</div>
</a>
<a href="../2018/jmh.html" title="应用JMH测试大型HashMap的性能" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
应用JMH测试大型HashMap的性能
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright © Wayne Wang
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
<div class="md-footer-social">
<a href="https://github.com/waynewang12" class="md-footer-social__link fa fa-github"></a>
</div>

</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});

var clientId = 'baf13252e688e141e06b';
var clientSecret = '5046d2b88f2c31f848a8d8f855f0f25811ff64f4';
var gitment = new Gitment({
id: 'middleware race preliminary',
owner: 'WayneWang12',
repo: 'WayneWang12.github.io',
oauth: {
client_id: clientId,
client_secret: clientSecret,
},
});

gitment.render('comments');

</script>
<script>!function(e,a,t,n,o,c,i){e.GoogleAnalyticsObject=o,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),i=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(c,i)}(window,document,"script",0,"ga"),ga("create","UA-124806176-1"),ga("set","anonymizeIp",!0),ga("send","pageview");var links=document.getElementsByTagName("a");Array.prototype.map.call(links,function(e){e.host!=document.location.host&&e.addEventListener("click",function(){var a=e.getAttribute("data-md-action")||"follow";ga("send","event","outbound",a,e.href)})});if(document.forms.search){var query=document.forms.search.query;query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}</script>

</body>
</html>
